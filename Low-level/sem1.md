#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+LANGUAGE: ru
#+OPTIONS: ':t
#+OPTIONS: toc:1
#+OPTIONS: tasks:nil
#+TITLE: Семинар 1:  среда выполнения
 -----

 - На практических занятиях мы будем выполнять небольшую самостоятельную работу с помощью преподавателя практики.
 - Если вы успели выполнить все задания, то получаете 2.5 балла, в противном случае вы баллов не получаете.
 - Преподаватель практики может на своё усмотрение поощрять неполное решение.
 - Листочки содержат инструкции к выполнению заданий, немного теории и вопросы для проверки, находя ответы на которые вы продвигаетесь в изучении курса.

* Необходимые инструменты для курса
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
  - Для выполнения всех заданий курса вам достаточно иметь Debian GNU\Linux 8.0+ или аналогичный дистрибутив с установленными:
    * NASM 2.11.05+
    * GCC 4.9.2+ или Clang 
    * GNU Make 4.0+
    * GDB 7.7.1+

  - Лабораторные работы по ассемблеру будет очень сложно выполнить на MacOS если вы ещё на нём не писали т.к. эта операционная система требует того, чтобы код был позиционно-независимый (PIC, не содержит абсолютных адресов), а то, как этого достичь, мы изучим лишь в конце курса.

  - Лабораторные работы на чистом C можно выполнять на MacOS.

  - Пользователи Windows могут установить виртуальную машину или использовать WSL или WSL2.
  - Мы предоставляем несколько образов виртуальных машин для VirtualBox:
    - Ubuntu 16 with standard desktop environment (VirtualBox): https://yadi.sk/d/CLf4D4IM3TSpsx
    - Debian 9 Minimal (.vmx) https://yadi.sk/d/BehMKGzS3LgXzG
    - Debian 9 + XFCE https://yadi.sk/d/01uFWHCw3SHzh9

        Логин/пароль =user=, пароль от пользователя =root= --- =qwerty=

    - Docker image (не тестировалась) https://github.com/kellyi/nasm-gcc-container

* Tема занятия
  :PROPERTIES:
  :UNNUMBERED: t
  :END:

  Для выполнения заданий курса нам потребуется работать с командной строкой,
  использовать компилятор, линкер и отладчик. На этом занятии мы освежим уже
  известные нам навыки работы с ними и познакомимся с новыми сценариями
  использования.

  - Использование интерактивной оболочки
  - Переменные окружения
  - Компиляция ассемблерных программ
  - Флаги компиляции
  - Регулярные выражения, =grep=
  - ~stdin~, ~stdout~, ~stderr~


* Использование интерактивной оболочки 

  Любая операционная система предполагает наличие интерфейса взаимодействия между пользователем и различными компонентами компьютерной системы, т. е. наличие программного уровня, который поддерживает ввод команд и параметров для получения необходимых результатов. Такой программный уровень получил название /оболочка/ или, по-английски --- /shell/.

  Все оболочки имеют схожие функции и свойства:

  - Интерпретация команд.
  - Доступ к командам и результатам их выполнения.
  - Обработка файлов, операций стандартного ввода и вывода.
  - Реализация специального языка программирования оболочки.


** Вопросы (15 минут)
   :PROPERTIES:
   :UNNUMBERED: t
   :END:
   - Какую оболочку используете вы?
   - Как поменять оболочку, которая используется по умолчанию?
   - Чем особенна оболочка =sh= и почему мы редко её используем напрямую?
   - Для каких целей сейчас в основном используется =sh=?
   - Как вывести результат выполнения команды в файл?
   - Что такое дерево процессов?

   - Что такое =stdin=, =stdout=, =stderr=?
   - Как соединить выход одной программы со входом другой?
   - Когда целесообразно использовать =stdout=, а когда --- =stderr=?

   По умолчанию стандартный ввод --- чтение с клавиатуры, стандартный вывод и стандартный вывод ошибок печатаются на экране.


* Регулярные выражения. grep

** grep

   С помощью доллара в начале строки мы обозначаем приглашение командной строки,
   то есть текст после доллара нужно ввести.
  
   Выполните следующие команды. Что вы наблюдаете?
```
$ echo "hello, world" > test
$ echo "hello, " >> test
$ echo "world" >> test

$ grep 'hello' test
```


   Как видите, =grep= ищет строчки в файлах, удовлетворяющие шаблону.
   Однако его возможности больше, чем просто искать фиксированные строчки --- в качестве шаблона для поиска можно задавать /регулярные выражения/.

   Можно воспринимать регулярные выражения как маленькие программы на очень специализированном языке. С тем же файлом =test= выполните:

   ```
     $ grep 'hel*o' test
   ```

   Звёздочка в шаблоне означает "символ слева от звёздочки может повторяться ноль или более раз".

** Вопросы (15 минут)
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

   Используя [статью](https://www.opennet.ru/docs/RUS/bash_scripting_guide/c11895.html) ответьте на вопросы:

   - Как найти строчки из одного (любого) символа?
   - Как найти строчки с цифрами?
   - Как найти строчки где есть слово из трёх букв?
   - Как найти пустые строчки?
   - Какой ключ при запуске =grep= инвертирует результаты поиска, т.е. ищет строки, не удовлетворяющие шаблону? 


* Переменные окружения
  Переменные окружения --- именованные переменные, содержащие текстовую информацию, которую могут использовать запускаемые программы. Такие переменные могут содержать общие настройки системы, параметры графической или командной оболочки, данные о предпочтениях пользователя и многое другое.

  Некоторые переменные окружения хранят значения, которые используются для особых целей,  например:

  - директория, где по умолчанию ищутся динамические библиотеки :: =LD_LIBRARY_PATH=
  - место размещения исполняемых файлов в системе :: =PATH=
  - имя предпочитаемого текстового редактора :: =EDITOR=

** Вопросы (5 минут)
   :PROPERTIES:
   :UNNUMBERED: t
   :END:

   - Наследуются ли переменные окружения в дочерних процессах? Если да, то все ли?
   - Зачем нужен `export` при запуске программ?
   - Как установить значение переменной окружения и запустить программу?


* Компиляция ассемблерных программ 

  Файл с кодом, который мы создаём --- текстовый, с расширением `.asm`. Его перевод в исполняемый машинный код происходит в два этапа:

  -  Компилятор ::  создаёт из него объектный файл с расширением =.o=; в нём содержатся машинные инструкции, но вместо их операндов-адресов там заглушки.
  -  *Линкер* (компоновщик) :: создаёт из одного или более объектных файлов исполняемый (в *nix системах без расширения).

    Мы научимся компилировать программы на ассемблере пока даже не знакомясь с самим языком.
    
  Скомпилируйте первый файл =hello.asm= и создайте исполняемый файл `hello`:

  ```
      ; hello.asm 
        section .data
        message: db  'hello, world!', 10

        section .text
        global _start

        _start:
            mov     rax, 1           ; 'write' syscall number
            mov     rdi, 1           ; stdout descriptor
            mov     rsi, message     ; string address
            mov     rdx, 14          ; string length in bytes
            syscall

        mov     rax, 60          ; 'exit' syscall number
            xor     rdi, rdi
            syscall
  ```

  Для этого выполните команды:

```
$ nasm -g hello.asm -felf64 -o hello.o
$ ld -o hello hello.o
```

Для запуска:

``` 
./hello
```

В ответ на запуск вы должны увидеть:


``` 
Hello, world!
```


О флагах компиляции вы можете прочитать при помощи `man nasm`.

** Вопросы
  :PROPERTIES:
  :UNNUMBERED: t
  :END:
   - Что значит параметр `-f elf64`?
   - Что значит параметр `-g`?
   - Что такое отладчик?
